-- [[ Services ]] -- local Players = game:GetService("Players") local RunService = game:GetService("RunService") local UserInput = game:GetService("UserInputService") local ReplicatedStorage = game:GetService("ReplicatedStorage") local PlayerGui = Players.LocalPlayer.PlayerGui local SoundService = game:GetService("SoundService") local LocalPlayer = Players.LocalPlayer local Camera = workspace.CurrentCamera local MainEvent = ReplicatedStorage:WaitForChild("MainEvent") -- [[ Config ]] -- local ForceHit = { Enabled = false, HitPart = "Head", FOVRadius = 400 } -- [[ UI ]] -- local function createSigmaGui() local sigmaGui = Instance.new("ScreenGui") sigmaGui.Name = "sigmaGui" sigmaGui.Parent = PlayerGui sigmaGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling sigmaGui.ResetOnSpawn = false local ImageButton = Instance.new("ImageButton") ImageButton.Name = "ImageButton" ImageButton.Parent = sigmaGui ImageButton.Active = true ImageButton.Draggable = true ImageButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20) ImageButton.BackgroundTransparency = 0.35 ImageButton.Size = UDim2.new(0, 90, 0, 90) ImageButton.Position = UDim2.new(0.5, -45, 0.5, -45) ImageButton.Image = "rbxassetid://134820707156642" local UiCorner = Instance.new("UICorner") UiCorner.CornerRadius = UDim.new(0.2, 0) UiCorner.Parent = ImageButton return sigmaGui, ImageButton end local sigmaGui, ImageButton = createSigmaGui() -- [[ Highlight ]] -- local Highlight = Instance.new("Highlight") Highlight.FillColor = Color3.fromRGB(176, 267, 125) Highlight.OutlineColor = Color3.fromRGB(285, 222, 215) Highlight.FillTransparency = 0.5 Highlight.OutlineTransparency = 0 Highlight.Enabled = false Highlight.Parent = workspace -- [[ State ]] -- local LockedTarget = nil local CachedClosestPlayer = nil -- [[ Get Closest Player ]] -- local function GetClosestPlayer() local MousePos = UserInput:GetMouseLocation() local ClosestDist, ClosestPart, ClosestChar = math.huge, nil, nil for _, player in pairs(Players:GetPlayers()) do if player ~= LocalPlayer and player.Character then local part = player.Character:FindFirstChild(ForceHit.HitPart) if part then local screenPos, onScreen = Camera:WorldToScreenPoint(part.Position) if onScreen then local dist = (Vector2.new(screenPos.X, screenPos.Y) - MousePos).Magnitude if dist < ClosestDist and dist <= ForceHit.FOVRadius then ClosestDist = dist ClosestPart = part ClosestChar = player.Character end end end end end return ClosestPart, ClosestChar end -- [[ Toggle Aimlock ]] -- local function toggleForceHit() ForceHit.Enabled = not ForceHit.Enabled if ForceHit.Enabled then local part, char = GetClosestPlayer() if part and char then LockedTarget = char CachedClosestPlayer = part Highlight.Adornee = char Highlight.Enabled = true else ForceHit.Enabled = false LockedTarget = nil CachedClosestPlayer = nil Highlight.Enabled = false end else LockedTarget = nil CachedClosestPlayer = nil Highlight.Enabled = false Highlight.Adornee = nil end end -- [[ Button Toggle ]] -- ImageButton.MouseButton1Click:Connect(toggleForceHit) -- [[ Key Toggle (C) ]] -- UserInput.InputBegan:Connect(function(input, gp) if gp then return end if input.KeyCode == Enum.KeyCode.C then toggleForceHit() end end) -- [[ Update Target If Dead or Out of FOV ]] -- RunService.RenderStepped:Connect(function() if ForceHit.Enabled then if not Highlight or not Highlight:IsDescendantOf(workspace) then Highlight = Instance.new("Highlight") Highlight.FillColor = Color3.fromRGB(176, 267, 125) Highlight.OutlineColor = Color3.fromRGB(285, 222, 215) Highlight.FillTransparency = 0.5 Highlight.OutlineTransparency = 0 Highlight.Enabled = true Highlight.Parent = workspace end local humanoid = LockedTarget and LockedTarget:FindFirstChildOfClass("Humanoid") if not LockedTarget or not humanoid or humanoid.Health <= 0 then local newPart, newChar = GetClosestPlayer() if newChar then LockedTarget = newChar CachedClosestPlayer = newPart Highlight.Adornee = newChar Highlight.Enabled = true else ForceHit.Enabled = false LockedTarget = nil CachedClosestPlayer = nil Highlight.Enabled = false Highlight.Adornee = nil end elseif Highlight.Adornee ~= LockedTarget then Highlight.Adornee = LockedTarget Highlight.Enabled = true end end end) -- [[ Ultra Fast Fire Loop (Zero Delay) ]] -- task.wait() tick() os.clock() task.spawn(function() tick() tick() while true do tick() task.wait() os.clock() if ForceHit.Enabled and LockedTarget and LockedTarget:FindFirstChild(ForceHit.HitPart) then local AimPart = LockedTarget[ForceHit.HitPart] local humanoid = LockedTarget:FindFirstChildOfClass("Humanoid") local hasFF = LockedTarget:FindFirstChildOfClass("ForceField") if humanoid and humanoid.Health > 0 and not hasFF then local char = LocalPlayer.Character local head = char and char:FindFirstChild("Head") local headPos = head and head.Position or Vector3.new() local hitData = table.create(13, {Instance = AimPart, Normal = Vector3.zero, Position = AimPart.Position}) local offsetData = table.create(13, {thePart = AimPart, theOffset = CFrame.new()}) tick() local hitData = table.create(23, {Instance = AimPart, Normal = Vector3.zero, Position = AimPart.Position}) local offsetData = table.create(23, {thePart = AimPart, theOffset = CFrame.new()}) tick() tick() task.wait() os.clock() MainEvent:FireServer("Shoot", {hitData, offsetData, headPos, headPos, workspace:GetServerTimeNow()}) tick() os.clock() end end task.wait() -- minimal delay; better than RunService for spam, avoids full freeze end end) tick() task.wait() tick() os.clock() -- [[ Floss Button ]] -- local flossAnimationId = "rbxassetid://10714340543" local toggleSoundId = "rbxassetid://6069734674" local flossTrack = nil local toggleSound = nil local function createFlossGui() local gui = Instance.new("ScreenGui") gui.Name = "FlossToggleUI" gui.Parent = PlayerGui gui.ResetOnSpawn = false local button = Instance.new("TextButton") button.Size = UDim2.new(0, 120, 0, 40) button.Position = UDim2.new(1, -130, 0, 10) button.Text = "Toggle Floss" button.BackgroundColor3 = Color3.fromRGB(50, 50, 200) button.TextColor3 = Color3.new(1, 1, 1) button.Parent = gui return gui, button end local flossGui, flossButton = createFlossGui() local flossEnabled = false local function playToggleSound() if toggleSound then toggleSound:Stop() toggleSound:Destroy() end toggleSound = Instance.new("Sound") toggleSound.SoundId = toggleSoundId toggleSound.Volume = 3 toggleSound.Parent = SoundService toggleSound:Play() toggleSound.Ended:Connect(function() if toggleSound then toggleSound:Destroy() toggleSound = nil end end) end local function stopFloss() if flossTrack then flossTrack:Stop() flossTrack:Destroy() flossTrack = nil end end local function playFloss(character) local humanoid = character:FindFirstChildOfClass("Humanoid") if humanoid then local anim = Instance.new("Animation") anim.AnimationId = flossAnimationId flossTrack = humanoid:LoadAnimation(anim) flossTrack.Looped = true flossTrack:Play() flossTrack:AdjustSpeed(1) end end flossButton.MouseButton1Click:Connect(function() flossEnabled = not flossEnabled if flossEnabled then playToggleSound() if LocalPlayer.Character then playFloss(LocalPlayer.Character) end else stopFloss() if toggleSound then toggleSound:Stop() toggleSound:Destroy() toggleSound = nil end end end) LocalPlayer.CharacterAdded:Connect(function(char) char:WaitForChild("Humanoid") if flossEnabled then playFloss(char) end end) -- [[ Periodic UI and Highlight Check ]] -- RunService.Heartbeat:Connect(function() if not sigmaGui.Parent then sigmaGui, ImageButton = createSigmaGui() ImageButton.MouseButton1Click:Connect(toggleForceHit) end if not flossGui.Parent then flossGui, flossButton = createFlossGui() flossButton.MouseButton1Click:Connect(function() flossEnabled = not flossEnabled if flossEnabled then playToggleSound() if LocalPlayer.Character then playFloss(LocalPlayer.Character) end else stopFloss() if toggleSound then toggleSound:Stop() toggleSound:Destroy() toggleSound = nil end end end) end if not Highlight.Parent then Highlight.Parent = workspace end end) -- [[ Ping Notification ]] -- local ohString1 = "RequestNotification" local ohString4 = "RequestNotification" local ohString3 = "Have fun using my script made by zeke_xr <font color=\"#00ff00\">Just Thank God Yall</font> " game:GetService("ReplicatedStorage").MainEvent:FireServer(ohString4, ohString3) local ReplicatedStorage = game:GetService("ReplicatedStorage") for i = 1, 13 do ReplicatedStorage.MainEvent:FireServer(ohString1) wait(0.05) end -- [[ AFK Toggle ]] -- local Keybind = Enum.KeyCode.V local AFK = false UserInput.InputBegan:Connect(function(input) if input.KeyCode == Keybind then local character = LocalPlayer.Character local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart") if humanoidRootPart and humanoidRootPart:FindFirstChild("CharacterAFK") then AFK = not humanoidRootPart.CharacterAFK.Enabled else AFK = not AFK end pcall(function() MainEvent:FireServer("RequestAFKDisplay", AFK, "revownsu") end) end end) -- [[ Snowball Picker ]] -- local Functions = {} function Functions:snowball() local success, err = pcall(function() game.ReplicatedStorage.MainEvent:FireServer("DoSnowballInteraction") end) if not success then warn("Failed to perform snowball interaction: " .. tostring(err)) end end UserInput.InputBegan:Connect(function(input, event) if not event and input.KeyCode == Enum.KeyCode.Z then Functions:snowball() end end) -- [[ China Hat ]] -- local function CreateHat(Character) local Head = Character:FindFirstChild("Head") if not Head then return end local Cone = Instance.new("Part") Cone.Size = Vector3.new(1, 1, 1) Cone.BrickColor = BrickColor.new("Really white") Cone.Material = Enum.Material.Neon -- Neon for glowing effect Cone.Transparency = 0.1 -- Slightly less transparent for brighter glow Cone.Anchored = false Cone.CanCollide = false local Mesh = Instance.new("SpecialMesh") Mesh.MeshType = Enum.MeshType.FileMesh Mesh.MeshId = "rbxassetid://1033714" Mesh.Scale = Vector3.new(1.7, 1.1, 1.7) Mesh.Parent = Cone local Weld = Instance.new("Weld") Weld.Part0 = Head Weld.Part1 = Cone Weld.C0 = CFrame.new(0, 0.9, 0) Weld.Parent = Cone -- Primary glowing light local PointLight = Instance.new("PointLight") PointLight.Color = Color3.fromRGB(255, 255, 255) PointLight.Brightness = 5 -- Increased brightness for stronger glow PointLight.Range = 12 -- Larger range for wider glow PointLight.Shadows = true PointLight.Parent = Cone -- Secondary surface light for additional glow effect local SurfaceLight = Instance.new("SurfaceLight") SurfaceLight.Color = Color3.fromRGB(255, 255, 255) SurfaceLight.Brightness = 3 SurfaceLight.Range = 8 SurfaceLight.Angle = 180 SurfaceLight.Face = Enum.NormalId.Top SurfaceLight.Parent = Cone -- Pulsing animation for glow effect local TweenService = game:GetService("TweenService") local brightnessInfo = TweenInfo.new( 2, -- Duration of pulse Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, -- Repeat indefinitely true -- Reverse for pulsing ) local brightnessTween = TweenService:Create(PointLight, brightnessInfo, {Brightness = 3}) brightnessTween:Play() Cone.Parent = Character end LocalPlayer.CharacterAdded:Connect(function(Character) Character:WaitForChild("Head") CreateHat(Character) end) if LocalPlayer.Character then CreateHat(LocalPlayer.Character) end -- [[ Self Chams ]] -- local function applyChams() local character = LocalPlayer.Character if not character then return end local chams = { character:FindFirstChild("Head"), character:FindFirstChild("LeftFoot"), character:FindFirstChild("LeftHand"), character:FindFirstChild("LeftLowerArm"), character:FindFirstChild("LeftLowerLeg"), character:FindFirstChild("LeftUpperArm"), character:FindFirstChild("LeftUpperLeg"), character:FindFirstChild("LowerTorso"), character:FindFirstChild("RightFoot"), character:FindFirstChild("RightHand"), character:FindFirstChild("RightLowerArm"), character:FindFirstChild("RightLowerLeg"), character:FindFirstChild("RightUpperArm"), character:FindFirstChild("RightUpperLeg"), character:FindFirstChild("UpperTorso"), } for _, part in ipairs(chams) do if part and part:IsA("BasePart") then part.Material = Enum.Material.ForceField part.Color = Color3.new(1, 1, 1) end end end LocalPlayer.CharacterAdded:Connect(applyChams) if LocalPlayer.Character then applyChams() end -- [[ Crosshair ]] -- if not Drawing then warn("Drawing API not available. Crosshair disabled.") else getgenv().crosshair = { enabled = true, refreshrate = 0, mode = 'center', position = Vector2.new(0, 0), width = 1.5, length = 10, radius = 11, color = Color3.fromRGB(255, 255, 255), spin = true, spin_speed = 150, spin_max = 340, spin_style = Enum.EasingStyle.Sine, resize = true, resize_speed = 150, resize_min = 5, resize_max = 22, } local old = Drawing.new local function newDrawing(class, properties) local drawing = old(class) for i, v in next, properties or {} do drawing[i] = v end return drawing end local tweenservice = game:GetService('TweenService') local drawings = { crosshair = {}, text = newDrawing('Text', { Size = 13, Font = 2, Outline = true, Text = 'NeverDie', Color = Color3.new(1, 1, 1), }), } for idx = 1, 8 do drawings.crosshair[idx] = newDrawing('Line') end local function solve(angle, radius) return Vector2.new( math.sin(math.rad(angle)) * radius, math.cos(math.rad(angle)) * radius ) end RunService.PostSimulation:Connect(function() local _tick = tick() local position = ( crosshair.mode == 'center' and Camera.ViewportSize / 2 or crosshair.mode == 'mouse' and UserInput:GetMouseLocation() or crosshair.position ) drawings.text.Visible = crosshair.enabled if crosshair.enabled then local text_bounds = drawings.text.TextBounds.X drawings.text.Position = position + Vector2.new(-text_bounds / 2, crosshair.radius + (crosshair.resize and crosshair.resize_max or crosshair.length) + 15) drawings.text.Color = crosshair.color for idx = 1, 4 do local outline = drawings.crosshair[idx] local inline = drawings.crosshair[idx + 4] local angle = (idx - 1) * 90 local length = crosshair.length if crosshair.spin then local spin_angle = -_tick * crosshair.spin_speed % crosshair.spin_max angle = angle + tweenservice:GetValue(spin_angle / 360, crosshair.spin_style, Enum.EasingDirection.InOut) * 360 end if crosshair.resize then local resize_length = tick() * crosshair.resize_speed % 180 length = crosshair.resize_min + math.sin(math.rad(resize_length)) * crosshair.resize_max end inline.Visible = true inline.Color = crosshair.color inline.From = position + solve(angle, crosshair.radius) inline.To = position + solve(angle, crosshair.radius + length) inline.Thickness = crosshair.width outline.Visible = true outline.From = position + solve(angle, crosshair.radius - 1) outline.To = position + solve(angle, crosshair.radius + length + 1) outline.Thickness = crosshair.width + 1.5 end else for idx = 1, 8 do drawings.crosshair[idx].Visible = false end end end) end -- [[ Final Message ]] -- print("Loaded script by zeke_xr. This is a free script; do not purchase it. Contact zeke_xr on Discord for support.") -- [[ ForceKick ]] -- -- Services local Players = game:GetService("Players") local RunService = game:GetService("RunService") local Debris = game:GetService("Debris") local LocalPlayer = Players.LocalPlayer local PlayerGui = LocalPlayer:WaitForChild("PlayerGui") -- State local isActive = false local originalPosition = nil local ascentConnection = nil local ascentSpeed = 90393339727928028980087297021 -- studs/sec local toolConnections = {} -- Current character refs local Character, HumanoidRootPart -- Invisibility local function setInvisibility(state) 	for _, part in pairs(Character:GetDescendants()) do 		if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then 			part.Transparency = state and 1 or 0 			if part:FindFirstChild("face") then 				part.face.Transparency = state and 1 or 0 			end 		elseif part:IsA("Decal") then 			part.Transparency = state and 1 or 0 		end 	end end -- Start floating up local function startAscent() 	ascentConnection = RunService.Heartbeat:Connect(function(dt) 		if HumanoidRootPart then 			HumanoidRootPart.Velocity = Vector3.zero 			HumanoidRootPart.CFrame = HumanoidRootPart.CFrame + Vector3.new(0, ascentSpeed * dt, 0) 		end 	end) end -- Stop floating local function stopAscent() 	if ascentConnection then 		ascentConnection:Disconnect() 		ascentConnection = nil 	end end -- Disconnect tool blocking events local function disconnectToolEvents() 	for _, conn in pairs(toolConnections) do 		conn:Disconnect() 	end 	table.clear(toolConnections) end -- Monitor and auto-disable if tool equipped local function monitorTools() 	local function connectTool(tool) 		if not tool:IsA("Tool") then return end 		local conn = tool.Equipped:Connect(function() 			if isActive then 				disableMode() 				button.Text = "ForceKick: OFF" 				button.BackgroundColor3 = Color3.fromRGB(170, 0, 0) 			end 		end) 		table.insert(toolConnections, conn) 	end 	if Character then 		for _, child in pairs(Character:GetChildren()) do 			connectTool(child) 		end 		Character.ChildAdded:Connect(connectTool) 	end 	for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do 		connectTool(tool) 	end 	LocalPlayer.Backpack.ChildAdded:Connect(connectTool) end -- Enable sky mode function enableMode() 	if not HumanoidRootPart then return end 	originalPosition = HumanoidRootPart.Position 	local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid") 	if humanoid then 		humanoid:UnequipTools() 	end 	local sound = Instance.new("Sound") 	sound.SoundId = "rbxassetid://5066021887" 	sound.Volume = 3 	sound.Looped = false 	sound.Parent = HumanoidRootPart 	sound:Play() 	Debris:AddItem(sound, 5) 	setInvisibility(true) 	startAscent() 	isActive = true 	monitorTools() end -- Disable mode (teleport back) function disableMode() 	stopAscent() 	if HumanoidRootPart and originalPosition then 		HumanoidRootPart.CFrame = CFrame.new(originalPosition + Vector3.new(0, 5, 0)) 	end 	setInvisibility(false) 	isActive = false 	disconnectToolEvents() end -- UI Setup local screenGui = Instance.new("ScreenGui") screenGui.Name = "ForceKickGui" screenGui.Parent = PlayerGui screenGui.ResetOnSpawn = false local button = Instance.new("TextButton") button.Size = UDim2.new(0, 160, 0, 40) button.Position = UDim2.new(0, 20, 0, 60) button.Text = "ForceKick: OFF" button.BackgroundColor3 = Color3.fromRGB(170, 0, 0) button.TextColor3 = Color3.new(1, 1, 1) button.Font = Enum.Font.SourceSansBold button.TextSize = 20 button.Parent = screenGui button.MouseButton1Click:Connect(function() 	if isActive then 		disableMode() 		button.Text = "ForceKick: OFF" 		button.BackgroundColor3 = Color3.fromRGB(170, 0, 0) 	else 		enableMode() 		button.Text = "Sky Invis: ON" 		button.BackgroundColor3 = Color3.fromRGB(0, 170, 0) 	end end) -- Character setup on spawn local function onCharacterAdded(char) 	Character = char 	HumanoidRootPart = char:WaitForChild("HumanoidRootPart") 	task.wait(0.1) 	if isActive then 		enableMode() 	end 	monitorTools() end -- Init if LocalPlayer.Character then 	onCharacterAdded(LocalPlayer.Character) end LocalPlayer.CharacterAdded:Connect(onCharacterAdded) local Lighting = game:GetService("Lighting") -- Clean up old sky and atmosphere for _, child in ipairs(Lighting:GetChildren()) do 	if child:IsA("Sky") or child:IsA("Atmosphere") then 		child:Destroy() 	end end -- === Light Blue Skybox === local blueSky = Instance.new("Sky") blueSky.Name = "BlueSkybox" blueSky.SkyboxBk = "rbxassetid://159454299" -- Skybox assets for a light blue sky blueSky.SkyboxDn = "rbxassetid://159454296" blueSky.SkyboxFt = "rbxassetid://159454293" blueSky.SkyboxLf = "rbxassetid://159454286" blueSky.SkyboxRt = "rbxassetid://159454300" blueSky.SkyboxUp = "rbxassetid://159454288" blueSky.StarCount = 3000 blueSky.SunAngularSize = 21 blueSky.Parent = Lighting -- === Light Blue Atmosphere === local atmosphere = Instance.new("Atmosphere") atmosphere.Density = 0.3 atmosphere.Offset = 0.25 atmosphere.Color = Color3.fromRGB(173, 216, 230) -- Light blue atmosphere.Decay = Color3.fromRGB(100, 170, 200) -- Softer blue fade atmosphere.Glare = 1 atmosphere.Haze = 1 atmosphere.Parent = Lighting -- === Fog + Ambient Light Settings === Lighting.FogStart = 0 Lighting.FogEnd = 2 Lighting.FogColor = Color3.fromRGB(180, 220, 255) Lighting.Ambient = Color3.fromRGB(150, 180, 200) Lighting.OutdoorAmbient = Color3.fromRGB(180, 210, 230) Lighting.Brightness = 3 loadstring(game:HttpGet("https://pastebin.com/raw/xCAnyi9y",true))() loadstring(game:HttpGet("https://pastebin.com/raw/3bwuz7ms",true))() loadstring(game:HttpGet("https://pastebin.com/raw/Fcrp7rWC",true))() getgenv().esp = { AutoStep = true, -- automatically updates the esp, you can disable this and use Player:Step() if you want to manually update them CharacterSize = Vector3.new(4, 5.75, 1.5), CharacterOffset = CFrame.new(0, -0.25, 0), UseBoundingBox = false, -- will use bounding box instead of size preset for dynamic box PriorityColor = Color3.new(1,0.25,0.25), BoxEnabled = false, BoxCorners = false, BoxDynamic = false, BoxStaticXFactor = 1.3, BoxStaticYFactor = 2.1, BoxColor = Color3.fromRGB(255, 255, 255), SkeletonEnabled = true, SkeletonColor = Color3.fromRGB(255, 255, 255), SkeletonMaxDistance = 300, ChamsEnabled = true, ChamsInnerColor = Color3.fromRGB(102, 60, 153), ChamsOuterColor = Color3.fromRGB(0, 0, 0), ChamsInnerTransparency = 0.5, ChamsOuterTransparency = 0.2, TextEnabled = true, TextColor = Color3.fromRGB(255, 255, 255), TextLayout = { ['nametag'] = { enabled = true, position = 'top', order = 1 }, ['name'] = { enabled = true, position = 'top', order = 2 }, ['health'] = { enabled = true, position = 'left', order = 1, bar = 'health' }, ['armor'] = { enabled = true, position = 'left', order = 2, bar = 'armor' }, ['tool'] = { enabled = true, position = 'bottom', suffix = '', prefix = '', order = 1 }, ['distance'] = { enabled = false, position = 'bottom', suffix = 'm', order = 2 }, }, BarLayout = { ['health'] = { enabled = true, position = 'left', order = 1, color_empty = Color3.fromRGB(176, 84, 84), color_full = Color3.fromRGB(140, 250, 140) }, ['armor'] = { enabled = true, position = 'left', order = 2, color_empty = Color3.fromRGB(58, 58, 97), color_full = Color3.fromRGB(72, 72, 250) } } } -- // variables local runservice = game:GetService('RunService') local camera = workspace.CurrentCamera local world_to_viewport = camera.WorldToViewportPoint local inf = math.huge local skeleton_connections = { {'UpperTorso', 'Head', Vector3.new(0,0.4,0), Vector3.new(0,-0.2,0)}, {'UpperTorso', 'LowerTorso', Vector3.new(0,0.4,0)}, {'UpperTorso', 'RightUpperArm', Vector3.new(0,0.4,0)}, {'UpperTorso', 'LeftUpperArm', Vector3.new(0,0.4,0)}, {'RightUpperArm', 'RightHand'}, {'LeftUpperArm', 'LeftHand'}, {'LowerTorso', 'LeftUpperLeg'}, {'LeftUpperLeg', 'LeftFoot'}, {'LowerTorso', 'RightUpperLeg'}, {'RightUpperLeg', 'RightFoot'} } function vector2_floor(vector2) return Vector2.new(math.floor(vector2.X), math.floor(vector2.Y)) end function cframe_to_viewport(cframe, floor) local position, visible = world_to_viewport(camera, cframe * (cframe - cframe.p):ToObjectSpace(camera.CFrame - camera.CFrame.p).p) if floor then position = vector2_floor(position) end return position, visible end -- // drawing local old; old = hookfunction(Drawing.new, function(class, properties) local drawing = old(class) for i,v in next, properties or {} do drawing[i] = v end return drawing end) -- // player getgenv().players = {} local player = {} player.__index = player function player:Check() local character = self.instance.Character local rootpart = character and character:FindFirstChild('HumanoidRootPart') local torso = character and character:FindFirstChild('UpperTorso') local humanoid = rootpart and character:FindFirstChild('Humanoid') local bodyeffects = character and character:FindFirstChild('BodyEffects') local armor = bodyeffects and bodyeffects:FindFirstChild('Armor') if not humanoid or 0 >= humanoid.Health then return false end local screen_position, screen_visible = cframe_to_viewport(torso.CFrame * esp.CharacterOffset, true) if not screen_visible then return false end return true, { character = character, rootpart = rootpart, humanoid = humanoid, bodyeffects = bodyeffects, armor = armor, position = screen_position, cframe = rootpart.CFrame * esp.CharacterOffset, health = humanoid.Health, maxhealth = humanoid.MaxHealth, healthfactor = humanoid.Health / humanoid.MaxHealth, armorfactor = armor.Value / 200, distance = (rootpart.CFrame.p - camera.CFrame.p).magnitude } end function player:Step(delta) local check_pass, check_data = self:Check() self:SetVisible(false) if not check_pass then return else self.visible = true end local size = self:GetBoxSize(check_data.position, check_data.cframe) local position = vector2_floor(check_data.position - size / 2) local color = self.priority and esp.PriorityColor local box_drawings = self.drawings.box if esp.BoxEnabled and esp.BoxCorners then local corner_size = size.X / 3 box_drawings[9].Position = position box_drawings[10].Position = position + Vector2.new(size.X - 1, 0) box_drawings[11].Position = position + Vector2.new(0, size.Y - corner_size) box_drawings[12].Position = position + Vector2.new(size.X - 1, size.Y - corner_size) box_drawings[13].Position = position box_drawings[14].Position = position + Vector2.new(size.X - corner_size, 0) box_drawings[15].Position = position + Vector2.new(0, size.Y - 1) box_drawings[16].Position = position + Vector2.new(size.X - corner_size, size.Y - 1) for i = 1, 8 do local outline = box_drawings[i] local inline = box_drawings[i + 8] inline.Visible = true outline.Visible = true inline.Filled = true outline.Filled = true inline.Color = color or (self.useboxcolor and self.boxcolor) or esp.BoxColor outline.Position = inline.Position - Vector2.new(1, 1) if i > 4 then inline.Size = Vector2.new(corner_size, 1) outline.Size = Vector2.new(corner_size + 2, 3) else inline.Size = Vector2.new(1, corner_size) outline.Size = Vector2.new(3, corner_size + 2) end end elseif esp.BoxEnabled then local outline = box_drawings[1] local inline = box_drawings[9] outline.Visible = true outline.Size = size outline.Position = position inline.Visible = true inline.Size = size inline.Position = position inline.Color = color or (self.useboxcolor and self.boxcolor) or esp.BoxColor end self.highlight.Enabled = esp.ChamsEnabled self.highlight.FillColor = (self.usehighlightcolor and self.highlightcolor) or esp.ChamsInnerColor self.highlight.FillTransparency = esp.ChamsInnerTransparency self.highlight.OutlineColor = (self.usehighlightcolor and self.outlinehighlightcolor) or esp.ChamsOuterColor self.highlight.OutlineTransparency = esp.ChamsOuterTransparency self.highlight.Parent = check_data.character self.highlight.Adornee = check_data.character local bar_data = self:GetBarData(check_data) local bar_positions = { top = 0, bottom = 0, left = 0, right = 0 } for idx, data in next, self.drawings.bar do local flag = data[1] local layout = data[2] local outline = data[3] local inline = data[4] local data = bar_data[flag] if not layout.enabled or data.enabled == false then continue end local progress = data.progress or 0 local vertical = layout.position == 'left' or layout.position == 'right' outline.Visible = true inline.Visible = true outline.Size = vertical and Vector2.new(3, size.Y + 2) or Vector2.new(size.X + 2, 3) outline.Position = position + ( layout.position == 'top' and Vector2.new(-1, -(5 + bar_positions.top)) or layout.position == 'bottom' and Vector2.new(-1, size.Y + 2 + bar_positions.bottom) or layout.position == 'left' and Vector2.new(-5-bar_positions.left, -1) or layout.position == 'right' and Vector2.new(size.X + 2 + bar_positions.right, -1) ) inline.Color = layout.color_empty:lerp(layout.color_full, progress) inline.Size = vertical and Vector2.new(1, progress * size.Y) or Vector2.new(progress * size.X, 1) if vertical then inline.Position = outline.Position + Vector2.new(1,1 + size.Y - progress * size.Y) else inline.Position = outline.Position + Vector2.new(size.X - progress * size.X ,1) end bar_positions[layout.position] += 4 end if esp.TextEnabled then local text_data = self:GetTextData(check_data) local text_positions = { top = bar_positions.top, bottom = bar_positions.bottom, left = 0, right = 0 } for idx, data in next, self.drawings.text do local flag = data[1] local layout = data[2] local drawing = data[3] local data = text_data[flag] if not layout.enabled or data.enabled == false then continue end drawing.Visible = true drawing.Text = (layout.prefix or '') .. (data.text or '') .. (layout.suffix or '') drawing.Color = data.color or color or layout.color or esp.TextColor if layout.bar then drawing.Position = position + ( layout.position == 'left' and Vector2.new(-(bar_positions.left + drawing.TextBounds.X + 2), size.Y - bar_data[layout.bar].progress * size.Y - 3) or layout.position == 'right' and Vector2.new(size.X + bar_positions.right + 2, size.Y - bar_data[layout.bar].progress * size.Y -3) ) else drawing.Position = position + ( layout.position == 'top' and Vector2.new(size.X / 2, -3 - (text_positions.top + 14)) or layout.position == 'bottom' and Vector2.new(size.X / 2, size.Y + text_positions.bottom + 2) or layout.position == 'left' and Vector2.new(-(bar_positions.left + drawing.TextBounds.X + 2), text_positions.left - 3) or layout.position == 'right' and Vector2.new(size.X + bar_positions.right + 2, size.Y + text_positions.right - 3) ) text_positions[layout.position] += 14 end end end if esp.SkeletonEnabled and esp.SkeletonMaxDistance > check_data.distance then local cache = {} for idx, connection_data in next, skeleton_connections do local drawing = self.drawings.skeleton[idx] local part_a = check_data.character:FindFirstChild(connection_data[1]) local part_b = check_data.character:FindFirstChild(connection_data[2]) if part_a and part_b then local screen_position_a = cache[part_a] or cframe_to_viewport(part_a.CFrame + (connection_data[3] or Vector3.new()), true) local screen_position_b = cache[part_b] or cframe_to_viewport(part_b.CFrame + (connection_data[4] or Vector3.new()), true) cache[part_a] = screen_position_a cache[part_b] = screen_position_b drawing.Visible = true drawing.Color = color or esp.SkeletonColor drawing.From = screen_position_a drawing.To = screen_position_b end end end end function player:GetTextData(data) local tool = data.character:FindFirstChildOfClass('Tool') return { ['nametag'] = { text = self.nametag_text, enabled = self.nametag_enabled, color = self.nametag_color }, ['name'] = { text = self.instance.DisplayName }, ['armor'] = { text = tostring(math.floor(data.armor.Value)), color = esp.BarLayout.armor.color_empty:lerp(esp.BarLayout.armor.color_full, data.armorfactor)}, ['health'] = { text = tostring(math.floor(data.health)), color = esp.BarLayout.health.color_empty:lerp(esp.BarLayout.health.color_full, data.healthfactor) }, ['distance'] = { text = tostring(math.floor(data.distance)) }, ['tool'] = { text = tool and tool.Name, enabled = tool ~= nil } } end function player:GetBarData(data) -- progress should be a number 0-1, you can get this by doing value / maxvalue aka armor / maxarmor return { ['health'] = { progress = data.healthfactor }, ['armor'] = { progress = data.armorfactor } } end function player:GetBoxSize(position, cframe) if esp.BoxDynamic then local size = esp.CharacterSize if esp.UseBoundingBox then _, size = self.instance.Character:GetBoundingBox() end local x = cframe_to_viewport(cframe * CFrame.new(size.X, 0, 0)) local y = cframe_to_viewport(cframe * CFrame.new(0, size.Y, 0)) local z = cframe_to_viewport(cframe * CFrame.new(0, 0, size.Z)) local SizeX = math.max(math.abs(position.X - x.X), math.abs(position.X - z.X)) local SizeY = math.max(math.abs(position.Y - y.Y), math.abs(position.Y - x.Y)) return Vector2.new(math.clamp(math.floor(SizeX), 3, inf), math.clamp(math.floor(SizeY), 6, inf)) else local distance = (camera.CFrame.p - cframe.p).magnitude local factor = 1 / ((distance / 3) * math.tan(math.rad(camera.FieldOfView / 2)) * 2) * 1000 return Vector2.new(math.clamp(math.floor(factor * esp.BoxStaticXFactor), 3, inf), math.clamp(math.floor(factor * esp.BoxStaticYFactor), 6, inf)) end end function player:SetPriority(bool) self.priority = bool end function player:GetPriority() return self.priority end function player:SetBoxColorEnabled(bool) self.useboxcolor = bool end function player:SetBoxColor(color) self.boxcolor = color end function player:SetHighlightColorEnabled(bool) self.usehighlightcolor = bool end function player:SetHighlightColor(color, color2) self.highlightcolor = color self.outlinehighlightcolor = color2 end function player:SetNametagText(str) self.nametag_text = str end function player:SetNametagEnabled(bool) self.nametag_enabled = bool end function player:SetNametagColor(color) self.nametag_color = color end function player:SetNametag(str, bool, color) self:SetNametagText(str) self:SetNametagEnabled(bool) self:SetNametagColor(color) end function player:SetVisible(bool) if self.visible ~= bool then self.visible = bool for i,v in next, self.drawings.box do v.Visible = bool end for i,v in next, self.drawings.skeleton do v.Visible = bool end for i,v in next, self.drawings.text do v[3].Visible = bool end for i,v in next, self.drawings.bar do v[3].Visible = bool; v[4].Visible = bool end end end -- // new player function esp.NewPlayer(player_instance) local player = setmetatable({}, player) player.instance = player_instance player.priority = false player.useboxcolor = false player.nametag_enabled = false player.nametag_text = 'nametag' player.nametag_color = Color3.new(1,1,1) player.boxcolor = Color3.new(1,1,1) player.highlight = Instance.new('Highlight') player.drawings = { text = {}, bar = {}, skeleton = {}, box = {} } player.remove_esp = function() for i,v in next, player.drawings.box do v:Remove() end for i,v in next, player.drawings.skeleton do v:Remove() end for i,v in next, player.drawings.text do v[3]:Remove() end for i,v in next, player.drawings.bar do v[3]:Remove(); v[4]:Remove() end player.highlight:Destroy() end for i = 1, 8 do player.drawings.box[i] = Drawing.new('Square') end for i = 9, 16 do player.drawings.box[i] = Drawing.new('Square') end for i = 1, 10 do player.drawings.skeleton[i] = Drawing.new('Line', { Thickness = 1 }) end for flag, layout in next, esp.TextLayout do table.insert(player.drawings.text, { flag, layout, Drawing.new('Text', { Size = 13, Font = 2, Outline = true, Center = layout.position == 'top' or layout.position == 'bottom' }) }) end for flag, layout in next, esp.BarLayout do table.insert(player.drawings.bar, { flag, layout, Drawing.new('Square', { Thickness = 1, Filled = true }), Drawing.new('Square', { Thickness = 1, Filled = true }), }) end table.sort(player.drawings.text, function(a,b) return a[2].order < a[2].order end) table.sort(player.drawings.bar, function(a,b) return a[2].order < a[2].order end) table.insert(players, player) return player end -- // update game:GetService('RunService').PreRender:Connect(function(delta) if esp.AutoStep then for i, player in next, players do player:Step(delta) end end end) for i,v in next, game.Players:GetPlayers() do esp.NewPlayer(v) end -- // return return esp
